import{z as U,be as O,bf as V,Z as H,$ as z,a0 as k,A as T,bg as G,H as C,G as W,I as w,o as _,J as j,K as E,X as I,bh as N,V as F}from"./index.d7926f49.js";import{g as A}from"./useBVHMap.ae050dd6.js";import{b as J}from"./computeBVH.bb8a30ce.js";const b=new Set,K=()=>new WeakSet;U(function(){if(H()&&z()===k)return;const s=A();if(!s.length)return;const c=O(),y=V(),h=.02,B=T(()=>{G.clear();for(const t of b){const a=t.bvhVelocity,o=t.outerObject3d,m=t.bvhHalfHeight,n=t.bvhRadius;a.y+=t.bvhOnGround?0:h*-c;const{position:r}=t.physicsUpdate;t.physicsUpdate={},r&&(r.x&&(a.x=0),r.y&&(a.y=0),r.z&&(a.z=0)),o.position.addScaledVector(a,h),o.updateMatrixWorld();const{start:i,end:l}=w;l.copy(i.copy(o.position));const g=Math.max(m-n,0);l.y+=g,i.y-=g;const P=i.clone();C.setFromCenterAndSize(o.position,W.set(n*2,m*2,n*2));const v=j,S=E;let d=0,p,M=!1,u;for(const x of s)u=J.get(x),x.shapecast({intersectsBounds:f=>f.intersectsBox(C),intersectsTriangle:f=>{d=f.closestPointToSegment(w,v,S),d<n&&(M=!0,p=S.sub(v).normalize().multiplyScalar(n-d),i.add(p),l.add(p))}});M&&u&&_(G,t,K).add(u);const e=i.sub(P);t.bvhOnGround=e.y>Math.abs(h*a.y*.25),y&&t.bvhOnGround&&Math.abs(e.y/(e.x+e.z+Number.EPSILON))<y&&(t.bvhOnGround=!1);const R=Math.max(0,e.length()-1e-5);e.normalize().multiplyScalar(R),o.position.add(e),t.bvhOnGround?a.set(0,0,0):(e.normalize(),a.addScaledVector(e,-e.dot(a)))}});return()=>{B.cancel()}},[A,O,V,H,z]);function $(s){if(s.done)return;I.attach(this.outerObject3d),this.width=this.depth=Math.min(this.width,this.depth),this.physicsUpdate={};const c=N(this).multiplyScalar(.5);this.bvhHalfHeight=Math.max(c.y,.5),this.bvhRadius=Math.max(c.x,.5),this.bvhVelocity=new F,b.add(this),s.then(()=>{b.delete(this),this.physicsUpdate=void 0})}export{$ as default};
